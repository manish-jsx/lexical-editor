{"/tutorials/cms-integration":{"title":"Integrating with a CMS","data":{"":"In this tutorial, we'll show you how to integrate the Lexical Editor with a headless CMS, using a custom API for content persistence.","introduction#Introduction":"Modern content management often involves decoupling the CMS backend from the frontend display. Lexical Editor Easy can be integrated with any headless CMS that provides a content API. We'll demonstrate this using a generic REST API approach that you can adapt to your specific CMS.","prerequisites#Prerequisites":"A React application set up\nAccess to a headless CMS or API endpoint\nBasic understanding of async operations in JavaScript","installation#Installation":"First, install Lexical Editor Easy and its dependencies:\nnpm install lexical-editor-easy lexical @lexical/react react react-dom axios","setting-up-the-cms-connector#Setting up the CMS Connector":"Create a service to connect to your CMS:\n// src/services/cmsService.js\nimport axios from 'axios';\nconst API_URL = 'https://your-cms-api-endpoint.com/api';\nconst API_KEY = 'your-cms-api-key'; // Store this securely\nexport const cmsService = {\n  // Fetch a single content item by ID\n  async getContent(contentId) {\n    try {\n      const response = await axios.get(`${API_URL}/content/${contentId}`, {\n        headers: {\n          'Authorization': `Bearer ${API_KEY}`\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching content:', error);\n      throw error;\n    }\n  },\n  // Save or update content\n  async saveContent(contentId, data) {\n    try {\n      const response = await axios({\n        method: contentId ? 'PUT' : 'POST',\n        url: contentId ? `${API_URL}/content/${contentId}` : `${API_URL}/content`,\n        headers: {\n          'Authorization': `Bearer ${API_KEY}`,\n          'Content-Type': 'application/json'\n        },\n        data: {\n          content: data.content,\n          title: data.title,\n          status: data.status || 'draft',\n          // Add other metadata as required by your CMS\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error saving content:', error);\n      throw error;\n    }\n  },\n  \n  // List content items\n  async listContent(page = 1, limit = 20) {\n    try {\n      const response = await axios.get(`${API_URL}/content`, {\n        headers: {\n          'Authorization': `Bearer ${API_KEY}`\n        },\n        params: {\n          page,\n          limit\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error listing content:', error);\n      throw error;\n    }\n  }\n};","creating-the-cms-editor-component#Creating the CMS Editor Component":"Now create a component that uses the Lexical Editor with your CMS service:\n// src/components/CMSEditor.jsx\nimport React, { useState, useEffect } from 'react';\nimport { LexicalEditor, EditorToolbar, BlobImageUploader } from 'lexical-editor-easy';\nimport { cmsService } from '../services/cmsService';\nimport './CMSEditor.css';\nexport default function CMSEditor({ contentId }) {\n  const [initialContent, setInitialContent] = useState(null);\n  const [title, setTitle] = useState('');\n  const [isSaving, setIsSaving] = useState(false);\n  const [saveStatus, setSaveStatus] = useState('');\n  const [status, setStatus] = useState('draft');\n  \n  // Load content from CMS when component mounts or contentId changes\n  useEffect(() => {\n    if (contentId) {\n      const loadContent = async () => {\n        try {\n          const content = await cmsService.getContent(contentId);\n          setInitialContent(content.editorState);\n          setTitle(content.title || '');\n          setStatus(content.status || 'draft');\n        } catch (error) {\n          console.error('Failed to load content:', error);\n          setSaveStatus('Error loading content');\n        }\n      };\n      \n      loadContent();\n    }\n  }, [contentId]);\n  \n  // Handle editor content change and save\n  const handleContentChange = async (editorState) => {\n    // Only save if content has been loaded\n    if (initialContent === null) return;\n    \n    setIsSaving(true);\n    setSaveStatus('Saving...');\n    \n    try {\n      const result = await cmsService.saveContent(contentId, {\n        content: JSON.stringify(editorState),\n        title,\n        status\n      });\n      \n      setSaveStatus('Saved successfully');\n      // If this is a new content, we might want to update the URL with new ID\n      if (!contentId && result.id) {\n        window.history.pushState({}, '', `/editor/${result.id}`);\n      }\n    } catch (error) {\n      setSaveStatus('Error saving content');\n    } finally {\n      setIsSaving(false);\n      // Clear save status after a delay\n      setTimeout(() => setSaveStatus(''), 3000);\n    }\n  };\n  \n  // Handle content publish\n  const handlePublish = async () => {\n    setIsSaving(true);\n    setSaveStatus('Publishing...');\n    \n    try {\n      await cmsService.saveContent(contentId, {\n        content: initialContent,\n        title,\n        status: 'published'\n      });\n      \n      setStatus('published');\n      setSaveStatus('Published successfully');\n    } catch (error) {\n      setSaveStatus('Error publishing content');\n    } finally {\n      setIsSaving(false);\n      setTimeout(() => setSaveStatus(''), 3000);\n    }\n  };\n  \n  return (\n    <div className=\"cms-editor\">\n      <div className=\"cms-editor-header\">\n        <input\n          type=\"text\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          placeholder=\"Enter title...\"\n          className=\"cms-editor-title\"\n        />\n        \n        <div className=\"cms-editor-actions\">\n          <span className=\"cms-editor-status\">\n            Status: {status === 'draft' ? '🔵 Draft' : '🟢 Published'}\n          </span>\n          \n          <button \n            onClick={handlePublish}\n            disabled={isSaving || status === 'published'}\n            className=\"publish-button\"\n          >\n            {status === 'published' ? 'Published' : 'Publish'}\n          </button>\n          \n          {saveStatus && (\n            <span className=\"save-status\">{saveStatus}</span>\n          )}\n        </div>\n      </div>\n      \n      <LexicalEditor\n        initialState={initialContent}\n        onChange={handleContentChange}\n        placeholder=\"Start writing your content...\"\n      >\n        <EditorToolbar>\n          <BlobImageUploader buttonText=\"Insert Image\" />\n        </EditorToolbar>\n      </LexicalEditor>\n    </div>\n  );\n}","adding-styles-for-the-cms-editor#Adding Styles for the CMS Editor":"Create a CSS file for styling:\n/* src/components/CMSEditor.css */\n.cms-editor {\n  display: flex;\n  flex-direction: column;\n  max-width: 900px;\n  margin: 0 auto;\n  padding: 20px;\n}\n.cms-editor-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n}\n.cms-editor-title {\n  font-size: 24px;\n  padding: 10px;\n  border: 1px solid #e2e8f0;\n  border-radius: 4px;\n  flex: 1;\n  min-width: 200px;\n  margin-right: 15px;\n}\n.cms-editor-actions {\n  display: flex;\n  align-items: center;\n  gap: 15px;\n}\n.cms-editor-status {\n  font-size: 14px;\n  color: #4a5568;\n}\n.publish-button {\n  background-color: #4299e1;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  padding: 8px 16px;\n  cursor: pointer;\n}\n.publish-button:hover {\n  background-color: #3182ce;\n}\n.publish-button:disabled {\n  background-color: #cbd5e0;\n  cursor: not-allowed;\n}\n.save-status {\n  font-size: 14px;\n  color: #4a5568;\n  animation: fadeOut 3s forwards;\n}\n@keyframes fadeOut {\n  0% { opacity: 1; }\n  70% { opacity: 1; }\n  100% { opacity: 0; }\n}","content-list-component#Content List Component":"Let's create a component to list and manage content from the CMS:\n// src/components/ContentList.jsx\nimport React, { useState, useEffect } from 'react';\nimport { cmsService } from '../services/cmsService';\nimport './ContentList.css';\nexport default function ContentList({ onSelectContent }) {\n  const [contents, setContents] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [page, setPage] = useState(1);\n  const [hasMore, setHasMore] = useState(true);\n  \n  const loadContents = async (pageNum = 1) => {\n    setIsLoading(true);\n    \n    try {\n      const response = await cmsService.listContent(pageNum);\n      \n      if (pageNum === 1) {\n        setContents(response.items);\n      } else {\n        setContents([...contents, ...response.items]);\n      }\n      \n      setHasMore(response.hasMore);\n      setPage(pageNum);\n    } catch (error) {\n      console.error('Failed to load content list:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  useEffect(() => {\n    loadContents();\n  }, []);\n  \n  const createNewContent = () => {\n    onSelectContent(null); // null indicates new content\n  };\n  \n  const loadMore = () => {\n    if (!isLoading && hasMore) {\n      loadContents(page + 1);\n    }\n  };\n  \n  return (\n    <div className=\"content-list\">\n      <div className=\"content-list-header\">\n        <h2>Content Items</h2>\n        <button onClick={createNewContent} className=\"new-content-button\">\n          Create New\n        </button>\n      </div>\n      \n      {isLoading && page === 1 ? (\n        <div className=\"loading-indicator\">Loading content...</div>\n      ) : (\n        <>\n          {contents.length === 0 ? (\n            <div className=\"empty-state\">\n              No content found. Create your first content item!\n            </div>\n          ) : (\n            <ul className=\"content-items\">\n              {contents.map(item => (\n                <li key={item.id} className=\"content-item\">\n                  <div className=\"content-item-details\" onClick={() => onSelectContent(item.id)}>\n                    <h3 className=\"content-title\">{item.title || 'Untitled'}</h3>\n                    <div className=\"content-meta\">\n                      <span className={`content-status status-${item.status}`}>\n                        {item.status}\n                      </span>\n                      <span className=\"content-date\">\n                        {new Date(item.updatedAt).toLocaleString()}\n                      </span>\n                    </div>\n                  </div>\n                </li>\n              ))}\n            </ul>\n          )}\n          \n          {hasMore && (\n            <button \n              onClick={loadMore} \n              disabled={isLoading}\n              className=\"load-more-button\"\n            >\n              {isLoading ? 'Loading...' : 'Load More'}\n            </button>\n          )}\n        </>\n      )}\n    </div>\n  );\n}\nAdd the corresponding styles:\n/* src/components/ContentList.css */\n.content-list {\n  padding: 20px;\n  background-color: #f7fafc;\n  border-radius: 8px;\n  margin-bottom: 30px;\n}\n.content-list-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n}\n.new-content-button {\n  background-color: #4299e1;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  padding: 8px 16px;\n  cursor: pointer;\n}\n.new-content-button:hover {\n  background-color: #3182ce;\n}\n.content-items {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n.content-item {\n  background-color: white;\n  border-radius: 4px;\n  margin-bottom: 10px;\n  border: 1px solid #e2e8f0;\n  transition: all 0.2s;\n}\n.content-item:hover {\n  border-color: #4299e1;\n  transform: translateY(-2px);\n}\n.content-item-details {\n  padding: 15px;\n  cursor: pointer;\n}\n.content-title {\n  margin: 0 0 5px 0;\n  font-size: 18px;\n}\n.content-meta {\n  display: flex;\n  justify-content: space-between;\n  font-size: 14px;\n  color: #718096;\n}\n.content-status {\n  font-weight: 500;\n}\n.status-draft {\n  color: #3182ce;\n}\n.status-published {\n  color: #38a169;\n}\n.load-more-button {\n  width: 100%;\n  background-color: #edf2f7;\n  border: 1px solid #e2e8f0;\n  padding: 10px;\n  border-radius: 4px;\n  margin-top: 15px;\n  cursor: pointer;\n}\n.load-more-button:hover {\n  background-color: #e2e8f0;\n}\n.load-more-button:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n.loading-indicator, .empty-state {\n  padding: 20px;\n  text-align: center;\n  color: #718096;\n}","main-app-component#Main App Component":"Let's put it all together in an App component:\n// src/App.jsx\nimport React, { useState } from 'react';\nimport ContentList from './components/ContentList';\nimport CMSEditor from './components/CMSEditor';\nimport './App.css';\nfunction App() {\n  const [selectedContentId, setSelectedContentId] = useState(null);\n  const [isEditing, setIsEditing] = useState(false);\n  \n  const handleSelectContent = (contentId) => {\n    setSelectedContentId(contentId);\n    setIsEditing(true);\n  };\n  \n  const handleBackToList = () => {\n    setIsEditing(false);\n  };\n  \n  return (\n    <div className=\"app\">\n      <header className=\"app-header\">\n        <h1>CMS Editor Demo</h1>\n      </header>\n      \n      <main className=\"app-main\">\n        {isEditing ? (\n          <div>\n            <button onClick={handleBackToList} className=\"back-button\">\n              ← Back to List\n            </button>\n            <CMSEditor contentId={selectedContentId} />\n          </div>\n        ) : (\n          <ContentList onSelectContent={handleSelectContent} />\n        )}\n      </main>\n      \n      <footer className=\"app-footer\">\n        <p>Powered by lexical-editor-easy</p>\n      </footer>\n    </div>\n  );\n}\nexport default App;\nFinal styles for the App:\n/* src/App.css */\n.app {\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n.app-header {\n  background-color: #2d3748;\n  color: white;\n  padding: 1rem;\n  text-align: center;\n}\n.app-main {\n  flex: 1;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  width: 100%;\n}\n.app-footer {\n  background-color: #2d3748;\n  color: white;\n  padding: 1rem;\n  text-align: center;\n  margin-top: auto;\n}\n.back-button {\n  background: none;\n  border: none;\n  color: #4299e1;\n  font-size: 16px;\n  cursor: pointer;\n  margin-bottom: 20px;\n  padding: 0;\n}\n.back-button:hover {\n  text-decoration: underline;\n}","preview-component#Preview Component":"Let's add a preview component to see how the content would look when published:\n// src/components/ContentPreview.jsx\nimport React, { useState, useEffect } from 'react';\nimport { cmsService } from '../services/cmsService';\nimport './ContentPreview.css';\nexport default function ContentPreview({ contentId, onClose }) {\n  const [content, setContent] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  \n  useEffect(() => {\n    const loadContent = async () => {\n      setIsLoading(true);\n      \n      try {\n        const contentData = await cmsService.getContent(contentId);\n        setContent(contentData);\n      } catch (error) {\n        console.error('Failed to load content for preview:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    if (contentId) {\n      loadContent();\n    }\n  }, [contentId]);\n  \n  if (isLoading) {\n    return (\n      <div className=\"content-preview loading\">\n        <div className=\"preview-header\">\n          <h2>Preview</h2>\n          <button onClick={onClose} className=\"close-button\">✕</button>\n        </div>\n        <div className=\"preview-loading\">Loading preview...</div>\n      </div>\n    );\n  }\n  \n  if (!content) {\n    return (\n      <div className=\"content-preview error\">\n        <div className=\"preview-header\">\n          <h2>Preview</h2>\n          <button onClick={onClose} className=\"close-button\">✕</button>\n        </div>\n        <div className=\"preview-error\">Failed to load content</div>\n      </div>\n    );\n  }\n  \n  // Note: In a real implementation, you would use a proper HTML renderer\n  // for the Lexical JSON content. This is just a placeholder.\n  return (\n    <div className=\"content-preview\">\n      <div className=\"preview-header\">\n        <h2>Preview</h2>\n        <button onClick={onClose} className=\"close-button\">✕</button>\n      </div>\n      \n      <div className=\"preview-content\">\n        <h1 className=\"preview-title\">{content.title}</h1>\n        \n        <div className=\"preview-body\">\n          {/* \n            In reality, you would render the actual content from Lexical state here.\n            This could involve using a LexicalRichTextPlugin in read-only mode\n            or converting the Lexical state to HTML.\n          */}\n          <div className=\"preview-placeholder\">\n            [Content would be rendered here]\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\nAdd styles for the preview:\n/* src/components/ContentPreview.css */\n.content-preview {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  width: 60%;\n  max-width: 800px;\n  background-color: white;\n  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  display: flex;\n  flex-direction: column;\n}\n.preview-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 15px 20px;\n  border-bottom: 1px solid #e2e8f0;\n}\n.preview-header h2 {\n  margin: 0;\n}\n.close-button {\n  background: none;\n  border: none;\n  font-size: 20px;\n  cursor: pointer;\n  color: #718096;\n}\n.preview-content {\n  flex: 1;\n  padding: 20px;\n  overflow-y: auto;\n}\n.preview-title {\n  margin-top: 0;\n  margin-bottom: 20px;\n  font-size: 28px;\n}\n.preview-loading, .preview-error {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  color: #718096;\n}\n.preview-error {\n  color: #e53e3e;\n}\n.preview-placeholder {\n  padding: 40px;\n  border: 2px dashed #e2e8f0;\n  border-radius: 8px;\n  text-align: center;\n  color: #a0aec0;\n}","conclusion#Conclusion":"You've now created a comprehensive CMS integration with Lexical Editor Easy! This implementation includes:\nA CMS service for connecting to your API\nContent creation and editing with the Lexical Editor\nContent listing and management\nPublishing workflow\nContent preview\nYou can extend this foundation to include additional features like:\nUser permissions and roles\nContent versioning\nCollaborative editing\nMedia library integration\nSEO metadata\nCustom content types\nRemember to adapt the API connection code to your specific CMS's requirements and authentication methods."}},"/tutorials/collaborative-editing":{"title":"Building a Collaborative Editor","data":{"":"In this advanced tutorial, we'll create a collaborative editing experience using Lexical Editor Easy with Yjs and WebSockets. This allows multiple users to edit the same document simultaneously in real-time.","introduction#Introduction":"Real-time collaboration is a powerful feature for modern editors. It enables users to work together on the same document, seeing each other's changes instantly. This tutorial demonstrates how to implement collaborative editing using:\nLexical Editor Easy: Our base rich text editor\nYjs: A CRDT algorithm for conflict-free collaboration\nWebSocket: For real-time communication\nNeon PostgreSQL: For document persistence","prerequisites#Prerequisites":"Basic understanding of React and Node.js\nFamiliarity with WebSockets\nA Neon PostgreSQL database\nUnderstanding of basic Lexical Editor functionality","setting-up-the-project#Setting Up the Project":"Start by creating a new React application:\nnpx create-react-app collaborative-editor\ncd collaborative-editor\nInstall the necessary dependencies:\nnpm install lexical-editor-easy lexical @lexical/react @neondatabase/serverless\nnpm install yjs y-websocket @lexical/yjs uuid\nnpm install express ws cors","creating-the-backend-service#Creating the Backend Service":"First, let's create a simple WebSocket server for communication between clients. Create a file called server.js in your project root:\n// server.js\nconst express = require('express');\nconst http = require('http');\nconst WebSocket = require('ws');\nconst cors = require('cors');\n// Create express app and HTTP server\nconst app = express();\napp.use(cors());\nconst server = http.createServer(app);\n// Create WebSocket server\nconst wss = new WebSocket.Server({ server });\n// Track connected clients\nconst clients = new Map();\n// Helper function to broadcast messages to all clients except the sender\nfunction broadcast(message, senderId) {\n  [...clients.entries()].forEach(([clientId, client]) => {\n    if (clientId !== senderId && client.readyState === WebSocket.OPEN) {\n      client.send(message);\n    }\n  });\n}\n// Handle WebSocket connections\nwss.on('connection', (ws, req) => {\n  // Generate client ID\n  const clientId = req.url.split('=')[1] || Date.now().toString();\n  clients.set(clientId, ws);\n  \n  console.log(`Client connected: ${clientId}`);\n  \n  // Handle incoming messages\n  ws.on('message', (message) => {\n    try {\n      // Forward message to all other clients\n      broadcast(message, clientId);\n    } catch (error) {\n      console.error('Error handling message:', error);\n    }\n  });\n  \n  // Handle disconnection\n  ws.on('close', () => {\n    console.log(`Client disconnected: ${clientId}`);\n    clients.delete(clientId);\n  });\n  \n  // Send initial connection confirmation\n  ws.send(JSON.stringify({\n    type: 'connection-established',\n    clientId,\n    connectedClients: clients.size\n  }));\n});\n// Start server\nconst PORT = process.env.PORT || 4000;\nserver.listen(PORT, () => {\n  console.log(`Server is running on port ${PORT}`);\n});","creating-the-collaborative-plugin#Creating the Collaborative Plugin":"Now, let's create a collaborative plugin for our Lexical Editor. Create a new file at src/components/CollaborationPlugin.js:\nimport React, { useEffect, useState } from 'react';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createPortal } from 'react-dom';\nimport * as Y from 'yjs';\nimport { WebsocketProvider } from 'y-websocket';\nimport { CollaborationPlugin as LexicalCollaborationPlugin } from '@lexical/react/LexicalCollaborationPlugin';\nimport { v4 as uuidv4 } from 'uuid';\n// Generate a random user color\nfunction getRandomColor() {\n  return `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, '0')}`;\n}\n// Generate a random user name\nfunction getRandomName() {\n  const names = ['User', 'Editor', 'Writer', 'Author', 'Collaborator'];\n  return `${names[Math.floor(Math.random() * names.length)]} ${Math.floor(Math.random() * 1000)}`;\n}\n// Component to display user cursors\nfunction CollaboratorCursor({ color, name, position }) {\n  return position ? (\n    <div\n      className=\"collaborator-cursor\"\n      style={{\n        position: 'absolute',\n        top: position.top,\n        left: position.left,\n        backgroundColor: color,\n        transform: 'translateX(-50%)',\n      }}\n    >\n      <div className=\"cursor-line\" style={{ backgroundColor: color, width: 2, height: 24 }} />\n      <div \n        className=\"cursor-name\" \n        style={{ \n          backgroundColor: color, \n          color: '#fff', \n          padding: '2px 6px', \n          borderRadius: 3, \n          fontSize: 12 \n        }}\n      >\n        {name}\n      </div>\n    </div>\n  ) : null;\n}\n// Component to display connected users\nfunction UserStatus({ connectedUsers }) {\n  if (!connectedUsers.length) return null;\n  \n  return (\n    <div className=\"connected-users\">\n      <span>Connected users: </span>\n      <div className=\"user-avatars\">\n        {connectedUsers.map((user) => (\n          <div \n            key={user.clientId} \n            className=\"user-avatar\"\n            style={{ backgroundColor: user.color }}\n            title={user.name}\n          >\n            {user.name.charAt(0).toUpperCase()}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\nexport default function CollaborationPlugin({ documentId, userName, websocketUrl }) {\n  const [editor] = useLexicalComposerContext();\n  const [ydoc] = useState(new Y.Doc());\n  const [provider, setProvider] = useState(null);\n  const [connected, setConnected] = useState(false);\n  const [connectedUsers, setConnectedUsers] = useState([]);\n  const [clientId] = useState(uuidv4());\n  const [userColor] = useState(getRandomColor());\n  const [userInfo] = useState({\n    clientId,\n    name: userName || getRandomName(),\n    color: userColor,\n  });\n  \n  // Connect to WebSocket server\n  useEffect(() => {\n    if (!documentId) return;\n    \n    const wsProvider = new WebsocketProvider(\n      websocketUrl || 'ws://localhost:4000',\n      `document-${documentId}`,\n      ydoc,\n      { params: { id: clientId } }\n    );\n    \n    // Set up awareness protocol for user presence\n    const awareness = wsProvider.awareness;\n    awareness.setLocalStateField('user', userInfo);\n    \n    wsProvider.on('status', ({ status }) => {\n      setConnected(status === 'connected');\n    });\n    \n    wsProvider.on('sync', () => {\n      console.log('Document synchronized with server');\n    });\n    \n    awareness.on('change', () => {\n      const users = [];\n      awareness.getStates().forEach((state, clientId) => {\n        if (state.user) {\n          users.push({\n            clientId,\n            name: state.user.name,\n            color: state.user.color\n          });\n        }\n      });\n      setConnectedUsers(users);\n    });\n    \n    setProvider(wsProvider);\n    \n    return () => {\n      wsProvider.disconnect();\n    };\n  }, [documentId, ydoc, clientId, userInfo, websocketUrl]);\n  \n  return (\n    <>\n      {provider && (\n        <LexicalCollaborationPlugin\n          id={documentId}\n          providerFactory={() => provider}\n          shouldBootstrap={true}\n          username={userInfo.name}\n          cursorColor={userInfo.color}\n        />\n      )}\n      \n      {connected ? (\n        <div className=\"collaboration-status connected\">\n          <UserStatus connectedUsers={connectedUsers} />\n        </div>\n      ) : (\n        <div className=\"collaboration-status disconnected\">\n          Connecting...\n        </div>\n      )}\n    </>\n  );\n}","creating-the-collaborative-editor-component#Creating the Collaborative Editor Component":"Now, let's create the main collaborative editor component. Create a new file at src/components/CollaborativeEditor.js:\nimport React, { useState, useEffect } from 'react';\nimport { LexicalEditor } from 'lexical-editor-easy';\nimport { NeonPersistencePlugin } from 'lexical-editor-easy';\nimport CollaborationPlugin from './CollaborationPlugin';\nimport { initNeonDatabase } from 'lexical-editor-easy';\nimport './CollaborativeEditor.css';\nexport default function CollaborativeEditor({ documentId, userName }) {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [neonDb] = useState(() => initNeonDatabase({\n    connectionString: process.env.REACT_APP_NEON_DATABASE_URL,\n    useWebsockets: true\n  }));\n  \n  useEffect(() => {\n    // Set up database table if needed\n    neonDb.setupTables().catch(err => {\n      console.error('Error setting up tables:', err);\n    });\n  }, [neonDb]);\n  \n  // Handler when document is loaded\n  const handleLoad = () => {\n    setIsLoaded(true);\n  };\n  \n  return (\n    <div className=\"collaborative-editor-container\">\n      <div className=\"editor-header\">\n        <h2>Document: {documentId}</h2>\n        <div className=\"editor-status\">\n          {isLoaded ? 'Document loaded' : 'Loading document...'}\n        </div>\n      </div>\n      \n      <div className=\"editor-content\">\n        <LexicalEditor\n          placeholder=\"Start typing here... Others will see your changes in real-time!\"\n          className=\"collaborative-editor\"\n        >\n          {/* Plugin for document persistence */}\n          <NeonPersistencePlugin \n            connectionString={process.env.REACT_APP_NEON_DATABASE_URL}\n            contentId={documentId}\n            onLoad={handleLoad}\n            saveDelay={2000} // Longer delay for collaborative environments\n          />\n          \n          {/* Plugin for real-time collaboration */}\n          <CollaborationPlugin\n            documentId={documentId}\n            userName={userName}\n            websocketUrl=\"ws://localhost:4000\"\n          />\n        </LexicalEditor>\n      </div>\n    </div>\n  );\n}","adding-styling#Adding Styling":"Create src/components/CollaborativeEditor.css:\n.collaborative-editor-container {\n  width: 100%;\n  max-width: 900px;\n  margin: 0 auto;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n}\n.editor-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 16px;\n  padding-bottom: 16px;\n  border-bottom: 1px solid #e2e8f0;\n}\n.editor-header h2 {\n  margin: 0;\n  font-size: 20px;\n  font-weight: 600;\n}\n.editor-status {\n  font-size: 14px;\n  color: #718096;\n}\n.editor-content {\n  border: 1px solid #e2e8f0;\n  border-radius: 6px;\n  overflow: hidden;\n}\n.collaborative-editor {\n  min-height: 400px;\n  position: relative;\n}\n.collaboration-status {\n  position: fixed;\n  bottom: 16px;\n  right: 16px;\n  padding: 8px 12px;\n  border-radius: 6px;\n  font-size: 14px;\n  font-weight: 500;\n  z-index: 10;\n}\n.collaboration-status.connected {\n  background-color: #c6f6d5;\n  color: #276749;\n}\n.collaboration-status.disconnected {\n  background-color: #fed7d7;\n  color: #c53030;\n}\n.connected-users {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n}\n.user-avatars {\n  display: flex;\n  margin-left: 4px;\n}\n.user-avatar {\n  width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-weight: bold;\n  font-size: 12px;\n  margin-right: -8px;\n  border: 2px solid white;\n}\n.collaborator-cursor {\n  pointer-events: none;\n  z-index: 10;\n}\n.cursor-line {\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n.cursor-name {\n  white-space: nowrap;\n  position: absolute;\n  top: -20px;\n  left: 0;\n  pointer-events: none;\n}","main-app-component#Main App Component":"Update src/App.js to include our collaborative editor:\nimport React, { useState } from 'react';\nimport CollaborativeEditor from './components/CollaborativeEditor';\nimport { v4 as uuidv4 } from 'uuid';\nimport './App.css';\nfunction App() {\n  const [userName, setUserName] = useState('');\n  const [documentId, setDocumentId] = useState('');\n  const [isJoined, setIsJoined] = useState(false);\n  \n  // Join or create a document\n  const handleJoinDocument = (e) => {\n    e.preventDefault();\n    if (documentId.trim() === '') {\n      setDocumentId(uuidv4());\n    }\n    setIsJoined(true);\n  };\n  \n  // Create a new document with a random ID\n  const handleCreateDocument = () => {\n    setDocumentId(uuidv4());\n    setIsJoined(true);\n  };\n  \n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Collaborative Editor</h1>\n      </header>\n      \n      <main className=\"App-content\">\n        {!isJoined ? (\n          <div className=\"join-container\">\n            <h2>Join or Create a Document</h2>\n            <form onSubmit={handleJoinDocument} className=\"join-form\">\n              <div className=\"form-group\">\n                <label htmlFor=\"userName\">Your Name</label>\n                <input\n                  type=\"text\"\n                  id=\"userName\"\n                  value={userName}\n                  onChange={(e) => setUserName(e.target.value)}\n                  placeholder=\"Enter your name\"\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"documentId\">Document ID (optional)</label>\n                <input\n                  type=\"text\"\n                  id=\"documentId\"\n                  value={documentId}\n                  onChange={(e) => setDocumentId(e.target.value)}\n                  placeholder=\"Enter document ID or leave empty to create new\"\n                />\n              </div>\n              \n              <div className=\"form-actions\">\n                <button type=\"button\" onClick={handleCreateDocument}>\n                  Create New Document\n                </button>\n                <button type=\"submit\">\n                  Join Document\n                </button>\n              </div>\n            </form>\n          </div>\n        ) : (\n          <CollaborativeEditor documentId={documentId} userName={userName} />\n        )}\n      </main>\n      \n      <footer className=\"App-footer\">\n        <p>Built with Lexical Editor Easy</p>\n      </footer>\n    </div>\n  );\n}\nexport default App;\nAdd some styling in src/App.css:\n.App {\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n.App-header {\n  background-color: #2c5282;\n  color: white;\n  padding: 16px;\n  text-align: center;\n}\n.App-header h1 {\n  margin: 0;\n  font-size: 24px;\n}\n.App-content {\n  flex: 1;\n  padding: 24px;\n}\n.App-footer {\n  background-color: #2c5282;\n  color: white;\n  padding: 16px;\n  text-align: center;\n  margin-top: auto;\n}\n.App-footer p {\n  margin: 0;\n}\n.join-container {\n  max-width: 500px;\n  margin: 0 auto;\n  padding: 24px;\n  background-color: #fff;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n}\n.join-container h2 {\n  margin-top: 0;\n  text-align: center;\n  margin-bottom: 24px;\n}\n.join-form {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n.form-group {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n.form-group label {\n  font-weight: 500;\n}\n.form-group input {\n  padding: 10px;\n  border: 1px solid #e2e8f0;\n  border-radius: 4px;\n  font-size: 16px;\n}\n.form-actions {\n  display: flex;\n  gap: 12px;\n  margin-top: 8px;\n}\n.form-actions button {\n  flex: 1;\n  padding: 12px;\n  border: none;\n  border-radius: 4px;\n  font-size: 16px;\n  font-weight: 500;\n  cursor: pointer;\n}\n.form-actions button[type=\"submit\"] {\n  background-color: #3182ce;\n  color: white;\n}\n.form-actions button[type=\"button\"] {\n  background-color: #e2e8f0;\n  color: #4a5568;\n}\n.form-actions button:hover {\n  opacity: 0.9;\n}","setting-up-environment-variables#Setting Up Environment Variables":"Create a .env file in your project root:\nREACT_APP_NEON_DATABASE_URL=your_neon_connection_string","running-the-application#Running the Application":"Let's set up the commands to run both the client and the server:Update your package.json:\n{\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"server\": \"node server.js\",\n    \"dev\": \"concurrently \\\"npm run server\\\" \\\"npm run start\\\"\"\n  }\n}\nInstall the concurrently package:\nnpm install concurrently --save-dev\nNow you can run the entire application with:\nnpm run dev","how-it-works#How It Works":"Let's break down how the collaborative editing works:\nYjs and CRDT: Yjs is a conflict-free replicated data type (CRDT) implementation, which allows multiple users to edit the same document simultaneously without conflicts. It handles synchronization between users automatically.\nWebSocket Communication: Changes from each client are transmitted via WebSockets to all other connected clients in real-time.\nLexical Collaboration Plugin: The Lexical editor has built-in support for collaborative editing via the CollaborationPlugin, which we're utilizing with our Yjs setup.\nUser Awareness: The collaboration plugin also tracks user cursors and selections, showing each user's current position in the document.\nPersistent Storage: While real-time changes are managed through WebSockets, we're also persisting changes to Neon PostgreSQL for long-term storage.","testing-the-collaborative-features#Testing the Collaborative Features":"To test the collaboration features:\nOpen the application in two different browser windows or devices\nJoin the same document using the same document ID\nStart typing in one window and observe the changes appear in real-time in the other window\nNotice how user cursors and selections are visible across different sessions","advanced-features-to-consider#Advanced Features to Consider":"Here are some ways to enhance your collaborative editor:","1-user-authentication#1. User Authentication":"Add authentication to ensure only authorized users can access specific documents:\nfunction AuthenticatedEditor({ user, documentId }) {\n  if (!user) {\n    return <LoginComponent />;\n  }\n  \n  return <CollaborativeEditor documentId={documentId} userName={user.name} />;\n}","2-document-history#2. Document History":"Track document revision history to allow users to see past versions:\nfunction EditorWithHistory({ documentId }) {\n  const [revisions, setRevisions] = useState([]);\n  const [selectedRevision, setSelectedRevision] = useState(null);\n  \n  // Fetch document revisions on mount\n  useEffect(() => {\n    async function fetchRevisions() {\n      // Implementation to fetch revisions from your backend\n    }\n    fetchRevisions();\n  }, [documentId]);\n  \n  return (\n    <div>\n      <CollaborativeEditor \n        documentId={documentId} \n        initialRevision={selectedRevision}\n      />\n      \n      <div className=\"revision-history\">\n        <h3>History</h3>\n        <ul>\n          {revisions.map(rev => (\n            <li key={rev.id} onClick={() => setSelectedRevision(rev.id)}>\n              {rev.date} by {rev.author}\n            </li>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n}","3-comment-threads#3. Comment Threads":"Add support for comments within the document:\nfunction CommentPlugin() {\n  const [editor] = useLexicalComposerContext();\n  const [comments, setComments] = useState([]);\n  \n  // Implementation for adding/displaying comments\n  \n  return (\n    <div className=\"comments-container\">\n      {comments.map(comment => (\n        <div key={comment.id} className=\"comment\">\n          <div className=\"comment-header\">\n            <span className=\"comment-author\">{comment.author}</span>\n            <span className=\"comment-date\">{comment.date}</span>\n          </div>\n          <div className=\"comment-content\">{comment.text}</div>\n        </div>\n      ))}\n    </div>\n  );\n}","conclusion#Conclusion":"You've now built a collaborative rich text editor with real-time synchronization between multiple users. This implementation combines:\nLexical Editor Easy for the rich text editing capabilities\nYjs for conflict-free real-time collaboration\nWebSockets for communication between clients\nNeon PostgreSQL for persistent storage\nThis foundation can be extended with more advanced features like access control, revision history, comments, and more based on your specific requirements.Real-time collaboration significantly enhances the user experience for document editing applications, making it possible for teams to work together efficiently regardless of their physical locations."}},"/troubleshooting":{"title":"Troubleshooting","data":{"":"This guide helps you solve common issues you might encounter when using Lexical Editor Easy.","installation-issues#Installation Issues":"","package-not-found#Package Not Found":"Problem: npm install fails with \"package not found\" error.Solution:\n# Make sure you're using the correct package name\nnpm install lexical-editor-easy\n# If that doesn't work, try clearing npm cache\nnpm cache clean --force\nnpm install lexical-editor-easy","peer-dependencies-missing#Peer Dependencies Missing":"Problem: Warnings about missing peer dependencies.Solution: Install the required peer dependencies:\nnpm install lexical @lexical/react react react-dom\nFor specific integrations:\n# For Vercel Blob support\nnpm install @vercel/blob\n# For Neon PostgreSQL support\nnpm install @neondatabase/serverless","editor-loading-issues#Editor Loading Issues":"","editor-doesnt-render#Editor Doesn't Render":"Problem: The editor doesn't appear on the page.Solution:\nCheck for JavaScript errors in the console\nMake sure you're importing the components correctly:\nimport { LexicalEditor } from 'lexical-editor-easy';\n// Not\nimport LexicalEditor from 'lexical-editor-easy';\nEnsure the editor is wrapped in a React component:\nfunction MyComponent() {\n  return (\n    <div>\n      <LexicalEditor />\n    </div>\n  );\n}","editor-crashes-with-type-errors#Editor Crashes with Type Errors":"Problem: TypeScript errors or runtime type errors related to the editor.Solution:\nMake sure you're using compatible versions of React and Lexical\nCheck that your TypeScript configuration is correct\nUpdate to the latest version of the package:\nnpm install lexical-editor-easy@latest","vercel-blob-integration-issues#Vercel Blob Integration Issues":"","images-fail-to-upload#Images Fail to Upload":"Problem: Images don't upload or return errors.Solution:\nCheck that your API route is properly configured:\n// /api/upload-blob.js\nimport { put } from '@vercel/blob';\nexport default async function handler(req, res) {\n  // ...implementation\n}\nVerify your environment variables are set:\nBLOB_READ_WRITE_TOKEN=your_vercel_blob_token\nCheck network requests in your browser's developer tools for specific error messages\nEnsure your Vercel project has Blob Storage enabled in the dashboard","access-denied-for-uploaded-images#\"Access Denied\" for Uploaded Images":"Problem: Images upload successfully but can't be viewed.Solution:\nMake sure you're using public access for images that need to be displayed:\nconst response = await uploadToVercelBlob(file, {\n  access: 'public',\n});\nCheck your Vercel project settings for Blob Storage permissions","neon-postgresql-integration-issues#Neon PostgreSQL Integration Issues":"","database-connection-fails#Database Connection Fails":"Problem: Can't connect to the Neon database, errors when saving content.Solution:\nVerify your connection string is correct:\nNEON_DATABASE_URL=postgresql://user:password@endpoint.pooler.region.neon.tech/database_name\nMake sure your Neon database is active and accessible\nCheck if you're trying to connect from a client-side component incorrectly (should use API routes instead)\nTry enabling WebSockets for the connection:\n<NeonPersistencePlugin\n  connectionString={process.env.NEON_DATABASE_URL}\n  useWebsockets={true}\n/>","content-not-saving#Content Not Saving":"Problem: Content changes aren't saved to the database.Solution:\nCheck for errors in the console\nVerify that your contentId is consistent across sessions:\n<NeonPersistencePlugin\n  connectionString={process.env.NEON_DATABASE_URL}\n  contentId=\"consistent-id-123\" // Use the same ID to update the same document\n/>\nTry increasing the saveDelay to ensure changes are complete before saving:\n<NeonPersistencePlugin\n  saveDelay={2000} // 2 seconds\n  // ...other props\n/>\nAdd error handling to see what's going wrong:\n<NeonPersistencePlugin\n  // ...other props\n  onError={(error) => console.error('Save error:', error)}\n/>","editor-behavior-issues#Editor Behavior Issues":"","formatting-commands-dont-work#Formatting Commands Don't Work":"Problem: Buttons like bold, italic, etc. don't apply formatting.Solution:\nMake sure the editor has focus when commands are issued\nCheck that you're using the built-in EditorToolbar or dispatching commands correctly:\nimport { FORMAT_TEXT_COMMAND } from 'lexical';\n// In your command handler:\neditor.dispatchCommand(FORMAT_TEXT_COMMAND, 'bold');","content-disappears-after-reload#Content Disappears After Reload":"Problem: Editor content is lost when the page is reloaded.Solution:\nImplement persistence with the Neon PostgreSQL integration:\n<LexicalEditor>\n  <NeonPersistencePlugin\n    connectionString={process.env.NEON_DATABASE_URL}\n    contentId=\"my-document\"\n  />\n</LexicalEditor>\nOr implement your own persistence mechanism:\nfunction EditorWithLocalStorage() {\n  const [initialContent, setInitialContent] = React.useState(null);\n  \n  // Load saved content on mount\n  React.useEffect(() => {\n    const saved = localStorage.getItem('editorContent');\n    if (saved) {\n      setInitialContent(saved);\n    }\n  }, []);\n  \n  // Save content on change\n  const handleEditorChange = (editorState) => {\n    const content = JSON.stringify(editorState);\n    localStorage.setItem('editorContent', content);\n  };\n  \n  return (\n    <LexicalEditor\n      initialState={initialContent}\n      onChange={handleEditorChange}\n    />\n  );\n}","still-having-issues#Still Having Issues?":"If you're still experiencing problems:\nCheck the GitHub repository for known issues\nSearch the repository issues to see if others have encountered the same problem\nOpen a new issue with:\nA clear description of the problem\nSteps to reproduce\nExpected vs actual behavior\nVersion information for lexical-editor-easy and relevant dependencies\nFor urgent issues, consider reaching out via the repository's contact channels"}}}